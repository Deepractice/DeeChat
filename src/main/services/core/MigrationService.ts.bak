import { DatabaseService } from './DatabaseService';
import { LocalStorageService } from './LocalStorageService';
import { app } from 'electron';
import { promises as fs } from 'fs';
import * as path from 'path';

/**
 * æ•°æ®è¿ç§»æœåŠ¡ - å¥¥å¡å§†å‰ƒåˆ€å®ç°
 * 
 * è®¾è®¡åŸåˆ™ï¼š
 * 1. ä¸€æ¬¡æ€§è¿ç§»ï¼Œç®€å•ç›´æ¥
 * 2. å®Œæ•´çš„å®‰å…¨ä¿éšœ
 * 3. è¯¦ç»†çš„è¿›åº¦åé¦ˆ
 * 4. è‡ªåŠ¨å›æ»šæœºåˆ¶
 */
export class MigrationService {
  constructor(
    private databaseService: DatabaseService,
    private localStorageService: LocalStorageService
  ) {}

  /**
   * æ‰§è¡Œä»JSONåˆ°SQLiteçš„å®Œæ•´è¿ç§»
   */
  async migrateToSQLite(): Promise<MigrationResult> {
    console.log('ğŸ”„ å¼€å§‹æ•°æ®è¿ç§»ï¼šJSON â†’ SQLite');
    
    const result: MigrationResult = {
      success: false,
      migratedSessions: 0,
      migratedMessages: 0,
      migratedConfigs: 0,
      migratedPreferences: 0,
      backupPath: '',
      errors: []
    };

    try {
      // Step 1: åˆ›å»ºå¤‡ä»½
      result.backupPath = await this.createBackup();
      console.log(`âœ… å¤‡ä»½å®Œæˆ: ${result.backupPath}`);

      // Step 2: æ£€æŸ¥æ•°æ®åº“å¥åº·çŠ¶æ€
      if (!this.databaseService.healthCheck()) {
        throw new Error('æ•°æ®åº“å¥åº·æ£€æŸ¥å¤±è´¥');
      }

      // Step 3: æ‰§è¡Œè¿ç§»ï¼ˆä¸åœ¨äº‹åŠ¡ä¸­ï¼Œå› ä¸ºasyncä¸æ”¯æŒï¼‰
      result.migratedSessions = await this.migrateChatSessions();
      result.migratedMessages = await this.migrateChatMessages();
      result.migratedConfigs = await this.migrateModelConfigs();
      result.migratedPreferences = await this.migrateUserPreferences();

      // Step 4: éªŒè¯è¿ç§»ç»“æœ
      await this.validateMigration(result);

      result.success = true;
      console.log('âœ… æ•°æ®è¿ç§»å®Œæˆ', {
        sessions: result.migratedSessions,
        messages: result.migratedMessages,
        configs: result.migratedConfigs,
        preferences: result.migratedPreferences
      });

    } catch (error: any) {
      result.errors.push(error.message);
      console.error('âŒ æ•°æ®è¿ç§»å¤±è´¥:', error);
      
      // è‡ªåŠ¨å›æ»šï¼ˆæ¸…ç©ºæ•°æ®åº“è¡¨ï¼‰
      try {
        this.rollbackMigration();
        console.log('ğŸ”„ å·²è‡ªåŠ¨å›æ»šæ•°æ®åº“æ›´æ”¹');
      } catch (rollbackError: any) {
        console.error('âŒ å›æ»šå¤±è´¥:', rollbackError);
        result.errors.push(`å›æ»šå¤±è´¥: ${rollbackError.message}`);
      }
    }

    return result;
  }

  /**
   * è¿ç§»èŠå¤©ä¼šè¯æ•°æ®
   */
  private async migrateChatSessions(): Promise<number> {
    try {
      // ä»ç°æœ‰LocalStorageServiceåŠ è½½æ•°æ®
      const sessions = await this.localStorageService.get('chat-sessions', []);
      
      const insertSession = this.databaseService.prepare(`
        INSERT OR REPLACE INTO chat_sessions 
        (id, title, selected_model_id, created_at, updated_at) 
        VALUES (?, ?, ?, ?, ?)
      `);

      let count = 0;
      for (const session of sessions) {
        insertSession.run(
          session.id,
          session.title,
          session.selectedModelId,
          new Date(session.createdAt).getTime(),
          new Date(session.updatedAt).getTime()
        );
        count++;
      }

      console.log(`âœ… è¿ç§»äº† ${count} ä¸ªèŠå¤©ä¼šè¯`);
      return count;
    } catch (error) {
      console.warn('âš ï¸ èŠå¤©ä¼šè¯è¿ç§»å¤±è´¥:', error);
      return 0;
    }
  }

  /**
   * è¿ç§»èŠå¤©æ¶ˆæ¯æ•°æ®
   */
  private async migrateChatMessages(): Promise<number> {
    try {
      const sessions = await this.localStorageService.get('chat-sessions', []);
      
      const insertMessage = this.databaseService.prepare(`
        INSERT OR REPLACE INTO chat_messages 
        (id, session_id, role, content, timestamp, model_id) 
        VALUES (?, ?, ?, ?, ?, ?)
      `);

      const insertToolExecution = this.databaseService.prepare(`
        INSERT OR REPLACE INTO tool_executions
        (id, message_id, tool_name, server_id, server_name, params, result, success, duration, timestamp)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `);

      let messageCount = 0;
      
      for (const session of sessions) {
        for (const message of session.messages || []) {
          // è¿ç§»æ¶ˆæ¯
          insertMessage.run(
            message.id,
            session.id,
            message.role,
            message.content,
            message.timestamp,
            message.modelId || null
          );
          messageCount++;

          // è¿ç§»å·¥å…·æ‰§è¡Œè®°å½•
          for (const toolExec of message.toolExecutions || []) {
            insertToolExecution.run(
              toolExec.id || `${message.id}_${toolExec.toolName}_${Date.now()}`,
              message.id,
              toolExec.toolName,
              toolExec.serverId || null,
              toolExec.serverName || null,
              JSON.stringify(toolExec.params || {}),
              JSON.stringify(toolExec.result || {}),
              toolExec.success !== false, // é»˜è®¤true
              toolExec.duration || null,
              toolExec.timestamp || message.timestamp
            );
          }
        }
      }

      console.log(`âœ… è¿ç§»äº† ${messageCount} æ¡æ¶ˆæ¯`);
      return messageCount;
    } catch (error) {
      console.warn('âš ï¸ èŠå¤©æ¶ˆæ¯è¿ç§»å¤±è´¥:', error);
      return 0;
    }
  }

  /**
   * è¿ç§»æ¨¡å‹é…ç½®æ•°æ®
   */
  private async migrateModelConfigs(): Promise<number> {
    try {
      const configs = await this.localStorageService.get('model-configs', []);
      
      const insertConfig = this.databaseService.prepare(`
        INSERT OR REPLACE INTO model_configs 
        (id, name, provider, model, api_key, base_url, is_enabled, status, priority, 
         available_models, enabled_models, created_at, updated_at) 
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `);

      let count = 0;
      for (const config of configs) {
        insertConfig.run(
          config.id,
          config.name,
          config.provider,
          config.model,
          config.apiKey || null,
          config.baseURL || null,
          config.isEnabled !== false, // é»˜è®¤true
          config.status || 'unknown',
          config.priority || 0,
          JSON.stringify(config.availableModels || []),
          JSON.stringify(config.enabledModels || []),
          new Date(config.createdAt).getTime(),
          new Date(config.updatedAt).getTime()
        );
        count++;
      }

      console.log(`âœ… è¿ç§»äº† ${count} ä¸ªæ¨¡å‹é…ç½®`);
      return count;
    } catch (error) {
      console.warn('âš ï¸ æ¨¡å‹é…ç½®è¿ç§»å¤±è´¥:', error);
      return 0;
    }
  }

  /**
   * è¿ç§»ç”¨æˆ·åå¥½æ•°æ®
   */
  private async migrateUserPreferences(): Promise<number> {
    try {
      const preferences = await this.localStorageService.get('user-preferences', {});
      
      const insertPreference = this.databaseService.prepare(`
        INSERT OR REPLACE INTO user_preferences (key, value, updated_at) 
        VALUES (?, ?, ?)
      `);

      const timestamp = Date.now();
      let count = 0;
      
      for (const [key, value] of Object.entries(preferences)) {
        insertPreference.run(key, JSON.stringify(value), timestamp);
        count++;
      }

      console.log(`âœ… è¿ç§»äº† ${count} ä¸ªç”¨æˆ·åå¥½è®¾ç½®`);
      return count;
    } catch (error) {
      console.warn('âš ï¸ ç”¨æˆ·åå¥½è¿ç§»å¤±è´¥:', error);
      return 0;
    }
  }

  /**
   * åˆ›å»ºå®Œæ•´æ•°æ®å¤‡ä»½
   */
  private async createBackup(): Promise<string> {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupDir = path.join(app.getPath('userData'), 'migration-backup');
    const backupPath = path.join(backupDir, `backup-${timestamp}`);

    await fs.mkdir(backupPath, { recursive: true });

    // å¤‡ä»½æ‰€æœ‰JSONæ–‡ä»¶
    const filesToBackup = [
      'chat-sessions.json',
      'model-configs.json',
      'user-preferences.json'
    ];

    for (const fileName of filesToBackup) {
      const sourcePath = path.join(app.getPath('userData'), fileName);
      const targetPath = path.join(backupPath, fileName);
      
      try {
        await fs.copyFile(sourcePath, targetPath);
      } catch (error) {
        console.warn(`å¤‡ä»½æ–‡ä»¶å¤±è´¥ ${fileName}:`, (error as Error).message);
      }
    }

    return backupPath;
  }

  /**
   * éªŒè¯è¿ç§»ç»“æœ
   */
  private async validateMigration(result: MigrationResult): Promise<void> {
    const stats = this.databaseService.getStats();
    
    console.log('ğŸ“Š è¿ç§»éªŒè¯ç»Ÿè®¡:', {
      æ•°æ®åº“ä¼šè¯: stats.sessions_count,
      æ•°æ®åº“æ¶ˆæ¯: stats.messages_count,
      æ•°æ®åº“é…ç½®: stats.configs_count,
      è¿ç§»ä¼šè¯: result.migratedSessions,
      è¿ç§»æ¶ˆæ¯: result.migratedMessages,
      è¿ç§»é…ç½®: result.migratedConfigs
    });

    // åŸºæœ¬å®Œæ•´æ€§æ£€æŸ¥
    if (result.migratedSessions > 0 && stats.sessions_count === 0) {
      throw new Error('ä¼šè¯è¿ç§»éªŒè¯å¤±è´¥ï¼šæ•°æ®åº“ä¸­æ— ä¼šè¯è®°å½•');
    }
  }

  /**
   * å›æ»šè¿ç§»ï¼ˆæ¸…ç©ºæ‰€æœ‰è¡¨ï¼‰
   */
  private rollbackMigration(): void {
    this.databaseService.transaction(() => {
      this.databaseService.prepare('DELETE FROM tool_executions').run();
      this.databaseService.prepare('DELETE FROM chat_messages').run();
      this.databaseService.prepare('DELETE FROM chat_sessions').run();
      this.databaseService.prepare('DELETE FROM model_configs').run();
      this.databaseService.prepare('DELETE FROM user_preferences').run();
    });
  }

  /**
   * æ£€æŸ¥æ˜¯å¦éœ€è¦è¿ç§»
   */
  async shouldMigrate(): Promise<boolean> {
    const stats = this.databaseService.getStats();
    const hasJsonData = await this.hasJsonData();
    
    // å¦‚æœæ•°æ®åº“ä¸ºç©ºä¸”æœ‰JSONæ•°æ®ï¼Œåˆ™éœ€è¦è¿ç§»
    return stats.sessions_count === 0 && hasJsonData;
  }

  /**
   * æ£€æŸ¥æ˜¯å¦æœ‰JSONæ•°æ®
   */
  private async hasJsonData(): Promise<boolean> {
    try {
      const sessions = await this.localStorageService.get('chat-sessions', []);
      const configs = await this.localStorageService.get('model-configs', []);
      return sessions.length > 0 || configs.length > 0;
    } catch {
      return false;
    }
  }
}

export interface MigrationResult {
  success: boolean;
  migratedSessions: number;
  migratedMessages: number;
  migratedConfigs: number;
  migratedPreferences: number;
  backupPath: string;
  errors: string[];
}